RocketMQ架构上主要分为四部分

	Producer   	消息发布的角色支持分布式集群方式部署。Producer通过MQ的负载均衡模块选择相应的broker集群队列进行消息投递，
				投递的过程支持快速失败并且低延迟
	
	Consumer	消息消费的角色，支持分布式集群方式部署。支持push推，pull拉两种模式对消息进行消费。同时支持集群方式
				和广播方式的消费，它提供实时消费订阅机制。
	
	NameServer	NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中zookeeper，支持broker的动态注册与发现。
				只要包括两个功能: broker管理，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后
				提供心跳检测机制，检测broker是否还存活。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。
				
				broker是向每一台NameServer注册自己的路由信息，所以每个实例上面都保存一份完整的路由信息。当某个NameServer
				因某种原因下线了，broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以动态感知broker的
				路由的信息
	
	BrokerServer	broker主要负责消息的存储，投递和查询以及服务高可用保证，为了实现这些功能，broker包含以下几个重要子模块
			
				
				Remoting Module		整个broker的实体，负责处理来自clients端的请求
				Client Manager		负责管理客户端(Producer/Consumer)和维护Consumer的topic订阅信息
				Store Service		提供方便简单的API接口处理消息存储当物理硬盘和查询功能
				HA Service			高可用服务，提供Master Broker和Slave Broker之间的数据同步功能
				Index Service		根据特定的Message Key对投递到Broker的消息的快速查询

RocketMQ网络部署特点
	
	NameServer是一个几乎无状态节点，可集群部署，节点之间无任何信息同步
	
	Broker部署相对复杂，Broker分为Master与Slave,一个Master可以对应多个Slave，但是一个Slave只能对应一个Slave
			Master与Slave 的对应关系通过指定相同的BrokerName，不同的BrokerId 来定义，BrokerId为0表示Master，
			非0表示Slave。Master也可以部署多个。每个Broker与NameServer集群中的所有节点建立长连接，定时注册
			Topic信息到所有NameServer。 注意：当前RocketMQ版本在部署架构上支持一Master多Slave，但只有BrokerId=1
			的从服务器才会参与消息的读负载。
			
	Producer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供
			Topic 服务的Master建立长连接，且定时向Master发送心跳。Producer完全无状态，可集群部署。
			
	Consumer与NameServer集群中的其中一个节点（随机选择）建立长连接，定期从NameServer获取Topic路由信息，并向提供
			Topic服务的Master、Slave建立长连接，且定时向Master、Slave发送心跳。Consumer既可以从Master订阅消息，
			也可以从Slave订阅消息，消费者在向Master拉取消息时，Master服务器会根据拉取偏移量与最大偏移量的距离
			（判断是否读老消息，产生读I/O），以及从服务器是否可读等因素建议下一次是从Master还是Slave拉取。		
			
集群部署架构图，描述集群工作流程:
		
	启动NameServer，NameServer起来后监听端口，等待Broker、Producer、Consumer连上来，相当于一个路由控制中心。
	
	Broker启动，跟所有的NameServer保持长连接，定时发送心跳包。心跳包中包含当前Broker信息(IP+端口等)以及存储所有Topic信息。注册成功后，NameServer集群中就有Topic跟Broker的映射关系。
	
	收发消息前，先创建Topic，创建Topic时需要指定该Topic要存储在哪些Broker上，也可以在发送消息时自动创建Topic。

	Producer发送消息，启动时先跟NameServer集群中的其中一台建立长连接，并从NameServer中获取当前发送的Topic存在哪些Broker上，轮询从队列列表中选择一个队列，然后与队列所在的Broker建立长连接从而向Broker发消息。
	
	Consumer跟Producer类似，跟其中一台NameServer建立长连接，获取当前订阅Topic存在哪些Broker上，然后直接跟Broker建立连接通道，开始消费消息		
			
			

基本概念
		
		消息模型(Message Mobel)
			RocketMQ主要由Producer, Broker, Consumer三部分组成，其中Producer负责生产消息，Consumer负责消息，Broker负责存储
			消息，Broker在实际部署过程中对应一台服务器，每个Broker可以存储多个Topic的消息，每个Topic也可以分片存储于不同的Broker，
			Message Queue用于存储消息的物理地址，每个Topic中的消息存储于多个Message Queue中，
			ConsumerGroup由多个Consumer实例构成。
		
		消息生产者(Producer)	
			负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产生的消息发送到broker服务器。RocketMQ提供多种
			发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。	
			
		消息消费者（Consumer）
			负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉取消息、并将其提供给应用程序。从用户应用的角度而言提供了两
			种消费形式：拉取式消费、推动式消费。	
		
		主题（Topic）
			表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是RocketMQ进行消息订阅的基本单位。
			
		代理服务器（Broker Server）
			消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也
			存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。
				
		名字服务（Name Server）
			名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。
			
		拉取式消费（Pull Consumer）
			Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。	
			
		推动式消费（Push Consumer）
			Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，该消费模式一般实时性较高。	

		生产者组（Producer Group）
同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事务消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生产者实例以提交或回溯消费。
	





		
			
			
			
			
			
			
			
			
			
			
			
			
			