zookeeper

分布式，开发源码的分布式应用程序协调服务，他是集群的管理者，监视着集群中各个节点的状态根据
提交的反馈进行下一步合理的操作，最终将简单易用的接口功效稳定的系统提供给用户

注册中心

rpc框架中三个重要角色



注册中心   保存所有服务的名称，服务提供者的ip列表    服务消费者的ip列表


服务提供者    提供跨进程服务

服务消费者	  寻找到指定命名的服务并消费


zookeeper可以充当服务注册表(service  registry)  让多个服务提供者形成一个集群
让服务消费者
通过服务注册表获取具体的服务访问列表(ip + 端口) 去访问具体的服务提供者


具体来说   分布式文件系统   

在zookeeper中，进行服务注册时，实际上就是在zookeeper中创建了一个znode节点，
该节点存储了该服务的ip，端口，调用方式(协议，序列化方式)，该节点承担着最重要
的职责，它由服务提供者(发布服务时)创建，以供服务消费者获取消费者节点中的信息
从而定位到服务提供者真正网络地址以及得知如何调用，rpc服务注册，发现过程简述如下：


1   服务提供者启动时，会将其服务名称，ip地址注册到配置中心(zookeeper)
2	服务消费者在第一次调用服务时，会通过注册中心找到相应的服务的ip地址列表，并缓存到
	本地，以供后续使用，当消费者调用服务时，不会再去请求注册中心
	而是直接通过负载均衡算法从ip列表中取一个服务提供者的服务器调用服务
3	当服务提供者的某个服务器宕机或下线时，相应的ip会从服务提供者ip列表中移除，同时，注册中心
	中心会将新的服务ip地址列表发送给服务消费者机器，缓存在消费者本机器
4   服务提供者的某台服务器上线时，注册中心会将新的服务ip地址列表发送给服务消费者机器
	缓存在消费者本机器
5 	服务提供方可以根据服务消费者的数量来作为服务下线的依据



感知服务的下线&上线
	zookeeper提供了"心跳检测功能"，  定时向各个服务提供者发送一个请求(实际上是建立socket长连接)，如果
	长期没有响应，服务中心就认为该服务提供者已经挂了
	
	比如100.100.0.237这台机器如果宕机了，那么zookeeper上的路径就会只剩/HelloWorldService/1.0.0/100.100.0.238:16888。

	服务消费者会去监听相应路径（/HelloWorldService/1.0.0），一旦路径上的数据有任务变化（增加或减少），zookeeper都会通知服务消费方、服务提供者地址列表已经发生改变，从而进行更新。
	
	zookeeper   集群    leader 选举     服务注册表高可用
	

zookeeper 系统架构

	zookeeper分为服务端(server)和客户端(client)， 客户端可以连接整个zookeeper服务的任意服务器上(除非leaderServes参数被显式设置，leader不允许客户端连接)
	
	客户端使用并维护一个tcp连接欸，通过这个连接发送请求，接受响应，获取观察的事件以及发送心跳，如果这个tcp连接中断，客户端将自动连接到另外
	的zookeeper服务器 客户端第一次连接到 ZooKeeper服务时，接受这个连接的 ZooKeeper服务器会为这个客户端建立一个会话。当这个客户端连接到另外的服务器时，
	这个会话会被新的服务器重新建立
	
	每一个Server代表一个安装Zookeeper服务的机器，即是整个提供Zookeeper服务的集群
	
	组成zookeeper服务的服务器之间必须彼此了解，他们维护一个内存中的状态图像，以及持久存储中事务日志和快照，只要大多数服务器可用，zookeeper就可用
	
	zookeeper服务启动时，将从实例中选举一个leader，leader负责处理数据更新等操作，一个更新操作成功的标志是当前且仅当大多数内存中成功修改数据，每个server在
	内存忠存储一份数据

	Zookeeper是可以集群复制的，集群间通过Zab协议（Zookeeper Atomic Broadcast）来保持数据的一致性；

	Zab协议包含两个阶段：leader election阶段和Atomic Brodcast阶段。

		a) 集群中将选举出一个leader，其他的机器则称为follower，所有的写操作都被传送给leader，并通过brodcast将所有的更新告诉给follower。
		b) 当leader崩溃或者leader失去大多数的follower时，需要重新选举出一个新的leader，让所有的服务器都恢复到一个正确的状态。
		c) 当leader被选举出来，且大多数服务器完成了 和leader的状态同步后，leadder election 的过程就结束了，就将会进入到Atomic brodcast的过程。
		d) Atomic Brodcast同步leader和follower之间的信息，保证leader和follower具有相同的系统状态
		
zookeeper的工作原理
	
	原子广播	这个机制保证了各个server之间的同步，实现这个机制的协议叫zab协议(原子广播协议)
			
	
		zab协议(原子广播协议)
			基本模式   
				崩溃恢复数据恢复
				消息广播之原子广播
				当整个集群正在启动时，或者当leader节点出现网络中断，崩溃等情形，zab协议就会进入恢复模式并选举产生新的leader，当leader服务器选举出来后，并且集群中有过半的机器和该leader节点完成数据同步后（同步指的是数据同步，用来保证集群中过半的机器能够和leader服务器的数据状态保持一致），ZAB协议就会退出恢复模式
				
				当集群中已经有过半的follower节点完成了和leader状态同步以后，那么整个集群就会进入消息广播模式，这个时候，在Leader节点正常工作时，启动一台新的服务器加入到集群，那这个服务器会直接进入数据恢复模式，和leader节点进行数据同步。同步完成后即可正常对外提供非事务请求的处理
				
			原子广播
				1 leader接收到消息请求后，将消息赋予一个全局唯一的64位自增id，叫 zxid，通过zxid的大小比较久可以实现因果有序这特性
				2 leader为每个follower准备一个FIFO队列，（通过tcp协议实现，以实现全局有序这一特点），将带有zxid的消息作为一个提案(proposal)分发给所有follower
				3 当follower接受到proposal，先把proposal写道磁盘，写入成功后再像leader回复一个ack
				4 当leader接收到合法数量(超过半数节点)的ack后，leader就会像这些follower发送commit命令，同时会在本地执行改消息
				5 当follower收到消息的commit命令后，会提交该消息
			数据恢复
			
			为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加 上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一 个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。

			epoch：可以理解为皇帝的年号，当新的皇帝leader产生后，将有一个新的epoch年号。

			每个Server在工作过程中有三种状态：

				LOOKING：当前Server不知道leader是谁，正在搜寻。
				LEADING：当前Server即为选举出来的leader。
				FOLLOWING：leader已经选举出来，当前Server与之同步。
zookeeper节点ZNode和相关属性
		两种类型
			持久的(persistent): 客户端和服务端断开连接后，创建的节点不删除
			短暂的(ephemeral): 客户端和服务端断开连接后，创建节点自己删除
		cZxid   数据节点创建时的事务id
		mZxid	修改时最新事务id
		
				
选举流程
		zookeeper的核心是原子广播，这个机制保证了各个server之间的同步，实现这个机制的协议叫zab协议
		恢复机制(选主)和广播模式(同步)
		
		服务启动或领导者崩溃后，Zab就进入恢复模式，领导者别选出来了，且大多数server完成了和leader的
		状态同步以后，恢复模式就结束了
		
		选举的两种场景：初始化，leader不可用
			服务初始化启动
			服务运行期间无法和leader保持连接
		当一台机器进入leader选举流程时，当前集群也可能处于以下两种状态
			集群中本来就存在一个leader   
				通常是集群某一台机器启动比较晚，集群已经正常运行，即已经存在一台leader信息，它仅仅需要和leader机器建立连接，并同步数据
			集群中确实不存在leader
				选主制度
				
				投票信息中包含两个最基本的信息
					sid：即server id，用来标识改机器咋集群中的机器序号
					zxid：即zookeeper事务id号
				
				zookeeper每一次状态的改变，都对应着一个递增的transaction id,该id称为zxid，由于zxid的递增性质， 如果zxid1小于zxid2,，那么zxid1肯定先于zxid2发生。创建任意节点，或者更新任意节点的数据， 或者删除任意节点，
				都会导致Zookeeper状态发生改变，从而导致zxid的值增加。
				
				以（sid，zxid）的形式来标识一次投票信息。
				
				集群中的每台机器发出自己的投票后，也会接受来自集群中其他机器的投票。每台机器都会根据一定的规则，来处理收到的其他机器的投票，
				以此来决定是否需要变更自己的投票
				
				投票机制
					初始阶段，都会给自己投票
					当接收到来自其他服务器的投票时，都需要将别人的投票和自己的投票进行pk，规则如下
					
					优先检查zxid。zxid比较大的服务器优先作为leader。如果zxid相同的话，就比较sid，sid比较大的服务器作为leader。

watch机制
	客户端(client)会对某个znode注册一个watcher事件，当该znode发生变化时，这些client会收到zookeeper的
	通知，然后客户端可以根据znode变化来做出业务上的改变
	
	使用场景  zookeeper为dobbo提供服务的注册与发现，作为注册中心，做到服务的注册与发现
		
		服务注册：服务提供者(provider)启动时,会向zookeeper服务端注册服务信息，也就是创建一个节点
			例如：用户注册服务com.xxx.user.register，并在节点上存储服务的相关数据（如服务提供者的ip地址、端口等）。
	
	
		
		